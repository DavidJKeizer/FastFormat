/*
* Copyright 2022 David James Keizer - refer to License.txt for MIT open-source license.
* Please refer to README.md for additional documentation on how to use FastFormat.
*/

#pragma once

#ifndef FASTFORMAT_H //Include gaurd,  pragma once is not supported all compilers.
#define FASTFORMAT_H

#include <stdint.h>		//Used to make overloads clear which data type is being used.
#include <string>		//Used for std::string and std::wstring support.
#include <wchar.h>		//User for wchar_t support.

//If this warning is encounterd (recursive on all control paths, runtime will cause runtime stack overflow) we CANNOT ignore it.
//This indicates that we have a circular loop in our template unpacking, that is Impl::FormatParameter(state, ARG) is calling itself.
//Impl::FormatParameter must terminate.
#pragma warning (error: 4717) 


#pragma warning(push)
#pragma warning(disable: 4514) //C4514 Unreferenced inline function has been removed. This warning will always be generated by the recursive template unpacking. We unpush this warning at the end of the file.

namespace FastFormat
{

	
	//FastFormat needs to return the number of characters written (as an int32_t) if succeeded, and an error code upon failure.
	//We use a typedef to indicate that the return type from the Format method(s) has unique behavior.
	typedef int32_t FormatResult;
	
	//A traditional non-class enum would provide us the option to return our enum as an int, but it non-scoped.
	//We scope the error codes to reduce namespace clutter.
	//We cannot use a class enum as we want to return the codes as an integer. 
	namespace FormatErrorCode 
	{
		static FormatResult const kNotEnoughSpace = -1;
		static FormatResult const kInvalidBufferPointer = -2;
		static FormatResult const kInvalidBufferCapacity = -3;
		static FormatResult const kBadParameter = -4;
		static FormatResult const kUnsupportedType = -5;
		static FormatResult const kInvalidCharacter = -6;
		static FormatResult const KInvalidArrayLength = -7;
		static FormatResult const kInvalidArrayPointer = -8;
	};

	//We use an int32_t to return how many characters we wrote to the buffer.
	//Therefore the buffer capacity cannot exceed the int32_t max value.
	//But we expose as size_t as it reduces the number of casts in the code, improving readability.
	//Realistically formatting characters over int32_t max value is not a common usecase.
	static size_t const MAX_BUFFER_CAPACITY =  static_cast<size_t>(std::numeric_limits<int32_t>::max());

	
	/*
	* Represents the current string being formatted.
	*/
	struct FormatState
	{
		wchar_t* pNext;
		size_t remainingCharacters;	
		size_t charactersWritten;
	};

	


	//To reduce namespace clutter, the template specializations for FormatParameter and other utilities functions are in their own namespace.
	//These are not intended to be used externally, so the namespace is anonamous, preventing access to these methods outside of the FastFormat header.
	namespace 
	{

		/**
		* Updates the pointer and character counts for the state, based on the number of characters writtern.
		*/
		inline void IncrementCharactersWritten(FormatState& state, size_t count) noexcept
		{
			state.pNext += count;
			state.remainingCharacters -= count;
			state.charactersWritten += count;
		}


		/// <summary>
		/// Counts the number of required characters to represent an integer as a string.
		/// A lookup table is faster than repeatedly dividing by 10, but is less flexible. 
		/// This solution WILL work regardless of number size. 
		/// </summary>
		/// <typeparam name="Integer"></typeparam>
		/// <param name="t"></param>
		/// <returns></returns>
		template<typename Integer> [[nodiscard]]
		inline size_t CountRequiredCharacters(Integer t) noexcept
		{

			size_t digits = 0;
			if (t < 0)
			{
				digits++; //Account for negative sign.
				t *= -1; //abs
			}

			//Count the places!
			do
			{
				t /= 10;
				digits++;
			} while (0 != t);

			
			return digits;
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, std::wstring const& wideString) {
			if (wideString.length() >= state.remainingCharacters)
			{
				return FormatErrorCode::kNotEnoughSpace;
			}

			//Copy the string to our output buffer.
			errno_t copyResult = wcscpy_s(state.pNext, state.remainingCharacters, wideString.c_str());

			switch (copyResult)
			{
			case EINVAL:
				return FormatErrorCode::kBadParameter;
			case ERANGE:
				return FormatErrorCode::kNotEnoughSpace;
			case 0:
				break; //Successfully copied the string.
			default:
				return FormatErrorCode::kBadParameter; //Should never happen, but handle just to be safe.
			}

			IncrementCharactersWritten(state, wideString.length());
			return static_cast<int32_t>(state.charactersWritten); //Safe to downsize, we check buffer size in primary Format method.
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, std::string const& string) {
	
			if (state.remainingCharacters <= string.length())
			{
				return FormatErrorCode::kNotEnoughSpace;
			}

			size_t charactersConverted = 0;
			errno_t result = mbstowcs_s(
				&charactersConverted,
				state.pNext,
				state.remainingCharacters,
				string.c_str(),
				string.length()
			);

			if (0 != result)
			{
				return FormatErrorCode::kNotEnoughSpace;
			}

			IncrementCharactersWritten(state, (charactersConverted-1)); //exclude null terminator
			return static_cast<int32_t>(state.charactersWritten); //Safe to downsize, we check buffer size in primary Format method.
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, wchar_t const* wideString)
		{
			if (wideString == nullptr)
			{
				return static_cast<int32_t>(state.charactersWritten);  //String is empty. Safe to downsize, we check buffer size in primary Format method.
			}
			
			//Do we have enough space to copy this string into our buffer?				
			size_t length = wcsnlen_s(wideString, state.remainingCharacters);
			if (length +1 >= state.remainingCharacters)
				return FormatErrorCode::kNotEnoughSpace;

			//Copy the string to our output buffer.
			errno_t copyResult = wcscpy_s(state.pNext, state.remainingCharacters, wideString);

			switch (copyResult)
			{
			case EINVAL:
				return FormatErrorCode::kBadParameter;
			case ERANGE:
				return FormatErrorCode::kNotEnoughSpace;
			case 0:
				break; //Successfully copied the string.
			default:
				return FormatErrorCode::kBadParameter; //Should never happen, but handle just to be safe.
			}

			IncrementCharactersWritten(state, length);
			return static_cast<int32_t>(state.charactersWritten); //Safe to downsize, we check buffer size in primary Format method.
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, char const* string)
		{
			if (nullptr == string)
			{
				return static_cast<int32_t>(state.charactersWritten); //empty string. Safe to downsize, we check buffer size in primary Format method.
			}
			

			size_t length = strnlen_s(string, state.remainingCharacters); 
			if (length +1>= state.remainingCharacters) //+1 for null terminator
			{
				return FormatErrorCode::kNotEnoughSpace;
			}

			size_t charactersConverted = 0;
			errno_t result = mbstowcs_s(
				&charactersConverted,
				state.pNext,
				state.remainingCharacters,
				string,
				state.remainingCharacters
			);

			if (0 != result)
			{
				return FormatErrorCode::kNotEnoughSpace;
			}

			IncrementCharactersWritten(state, length);
			return static_cast<int32_t>(state.charactersWritten); //Safe to downsize, we check buffer size in primary Format method.
		}

		
		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, int32_t number)
		{
			size_t length = CountRequiredCharacters(number);
			if (length >= state.remainingCharacters)
				return FormatErrorCode::kNotEnoughSpace;

			errno_t result = _itow_s(
				number,
				state.pNext,
				state.remainingCharacters,
				10);

			if (0 != result)
			{
				return FormatErrorCode::kNotEnoughSpace;
			}
			
			IncrementCharactersWritten(state, length);

			return static_cast<int32_t>(state.charactersWritten); //Safe to downsize, we check buffer size in primary Format method.
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, uint8_t number)
		{
			//Note that we MUST declare the overload before this, otherwise the compiler will just crush the number back to a uint8_t, and match against this function.
			return FormatParameter(state, static_cast<int32_t>(number)); //just widen and use standard int version
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, int8_t number)
		{
			//Note that we MUST declare the overload before this, otherwise the compiler will just crush the number back to a uint8_t, and match against this function.
			return FormatParameter(state, static_cast<int32_t>(number)); //just widen and use standard int version
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, int16_t number)
		{
			//Note that we MUST declare the overload before this, otherwise the compiler will just crush the number back to a uint8_t, and match against this function.
			return FormatParameter(state, static_cast<int32_t>(number)); //just widen and use standard int version
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, uint16_t number)
		{
			//Note that we MUST declare the overload before this, otherwise the compiler will just crush the number back to a uint8_t, and match against this function.
			return FormatParameter(state, static_cast<int32_t>(number)); //just widen and use standard int version
		}



		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, int64_t number)
		{
			size_t length = CountRequiredCharacters(number);
			if (length >= state.remainingCharacters)
				return FormatErrorCode::kNotEnoughSpace;

			errno_t result = _i64tow_s(
				number,
				state.pNext,
				state.remainingCharacters,
				10
			);

			if (0 != result)
			{
				return FormatErrorCode::kNotEnoughSpace;
			}

	
			IncrementCharactersWritten(state, length);

			return static_cast<int32_t>(state.charactersWritten); //Safe to downsize, we check buffer size in primary Format method.
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, uint64_t number)
		{
			size_t length = CountRequiredCharacters(number);
			if (length >= state.remainingCharacters)
				return FormatErrorCode::kNotEnoughSpace;

			errno_t result = _ui64tow_s(
				number,
				state.pNext,
				state.remainingCharacters,
				10
			);

			if (0 != result)
			{
				return FormatErrorCode::kNotEnoughSpace;
			}

			IncrementCharactersWritten(state, length);

			return static_cast<int32_t>(state.charactersWritten); //Safe to downsize, we check buffer size in primary Format method.
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, uint32_t number)
		{
			//Note that we MUST declare the overload before this, otherwise the compiler will just crush the number back to a uint8_t, and match against this function.
			return FormatParameter(state, static_cast<int64_t>(number)); //just widen and use standard int64 version
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, float number)
		{
			int32_t digitsRequired = 10;
			if (number < 0)
				digitsRequired++;

#pragma warning( push )
#pragma warning( disable : 4710 ) //C4710 'swprinf' function not inlined. We suppress the warning, not inlining the swprintf call is not an issue.
			int result = swprintf(state.pNext, state.remainingCharacters, L"%.8f", number);
#pragma warning( pop )

			if (result <= 0)
				return FormatErrorCode::kNotEnoughSpace;

			IncrementCharactersWritten(state, static_cast<size_t>(result));

			return static_cast<int32_t>(state.charactersWritten); //Safe to downsize, we check buffer size in primary Format method.
		}

		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, double number)
		{
			int32_t digitsRequired = 18;
			if (number < 0)
				digitsRequired++;


#pragma warning( push )
#pragma warning( disable : 4710 ) //C4710 'swprinf' function not inlined. We suppress the warning, not inlining the swprintf call is not an issue.
			int result = swprintf(state.pNext, state.remainingCharacters, L"%.16f", number);
#pragma warning( pop )


			if (result <= 0)
				return FormatErrorCode::kNotEnoughSpace;

			IncrementCharactersWritten(state, static_cast<size_t>(result));

			return static_cast<int32_t>(state.charactersWritten); //Safe to downsize, we check buffer size in primary Format method.
		}


		/**
		* In the event that a nullpointer is passed in as an explicit parameter, we catch that edge case here. This does NOT handle pointers of type T that are null.
		*/
		[[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, std::nullptr_t)
		{
			return FormatParameter(state, L"nullptr");
		}

		/**
		* This template specialization is our base case if a type cannot be matched to an overload. We flag it as a compiler error. 
		*/
		template<typename T> [[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, T const& other) {
			static_assert(false, "Unsupported format parameter type: " __FUNCSIG__);
			return FormatResult::kUnsupportedType;
		}

		/**
		*		This template specialization is the base case for the recursive paramter processing. It allows the recursive FormatParameter parameter unpacking to unpack all parameters at compile time.
		*/

		[[nodiscard]]
		inline FormatResult FormatParameter() { return 0; }


		/**
		* Recursively unpacks the parameters, processing each parameter at a time. If any format parameter fails, the method returns early. 
		* Recursion is done at compile time. This is where the magic happens!
		*/
		template<typename TFirst, typename ... TRemaining> [[nodiscard]]
		inline FormatResult FormatParameter(FormatState& state, TFirst const& first, TRemaining const& ... remaining)
		{
			FormatResult result = FormatParameter(state, first);
			if (result < 0)
				return result;

			return FormatParameter(state, remaining...);
		}

	}

	/**
	* Formats the parameters into the provided buffer. 
	* Returns the number of characters written, or a negative error code on failure.
	*/
	template<typename TFirst, typename ... TRemaining> [[nodiscard]]
	FormatResult Format(wchar_t* pBuffer, int32_t bufferCapacity, TFirst const& first, TRemaining const& ... remaining)
	{
		if (pBuffer == nullptr)
			return FormatErrorCode::kInvalidBufferPointer;

		if (bufferCapacity <= 0)
			return FormatErrorCode::kInvalidBufferCapacity;	

		//We should have a valid working state to format our parameters into.
		FormatState state = { pBuffer, static_cast<size_t>(bufferCapacity), size_t() };

		FormatResult result =  ::FormatParameter(state, first, remaining...);
		if (result < 0)
		{
			pBuffer[0] = 0; //We encountered an error. Null terminate the buffer as it is no longer valid.
		}
		else
		{
			size_t lastCharacter = std::min(state.charactersWritten + 1, static_cast<size_t>(bufferCapacity));
			pBuffer[lastCharacter] = 0; //Be absolutely certain we null terminated the string.
		}
		return result;
	}

	
	/**
	* Formats an array, into a string of the format "[a, b, c, d]" where a, b, c, and d are all values of type Type.
	* Returns the number of characters written, or a negative error code on failure.
	*/
	template<typename Type> [[nodiscard]]
	FormatResult FormatArray(wchar_t* pBuffer, int32_t bufferCapacity, Type* pArray, size_t arrayLength)
	{
		if (pBuffer == nullptr)
			return FormatErrorCode::kInvalidBufferPointer;

		if (bufferCapacity <= 0)
			return FormatErrorCode::kInvalidBufferCapacity;

		if (pArray == nullptr)
			return FormatErrorCode::kInvalidArrayPointer;

		if (arrayLength == 0)
			return FormatErrorCode::KInvalidArrayLength;

		//We should have a valid working state to format our parameters into.
		FormatState state = { pBuffer, static_cast<size_t>(bufferCapacity), size_t() };

		//We have at least one item.
		FormatResult result = ::FormatParameter(state, L"[");
		if (result < 0)
			return result;

		for (size_t i = 0; i < (arrayLength -1); i++) //for all up to the last item
		{
			result = ::FormatParameter(state, pArray[i], L", "); 
			if (result < 0)
				return result;
		}

		return ::FormatParameter(state, pArray[arrayLength-1], L"]");

	}

	


} //end FastFormat namespace

#pragma warning(pop) //Re-Enable C4514 unreferenced inline function has been removed. 

#endif //FASTFORMAT_H